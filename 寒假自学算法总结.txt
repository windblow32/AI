（     一     ）
动态规划经典题目――0-1背包
            
            
                
                    
                    原创                                                                                                                                            仁者乐山智者乐水
                    最后发布于2019-08-07 11:31:16                    
                    阅读数 136
                    
                        
                        收藏
                    
                
                                
                
                
                                                                展开
                                    
            
        
    
    
        
                
                
                                    
         
            
                                        
                
                                            一、题目

有N件物品和一个容量为V的背包。第i件物品的重量是w[i]，价值是v[i]。求解将哪些物品装入背包可使这些物品的重量总和不超过背包容量，且价值总和最大。

二、解题思路

动态规划解题思路可详见另一篇文章。

①定义状态

这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。所以称为0-1背包。用子问题定义状态：即dp[i][j]表示前i件物品恰放入一个容量为j的背包可以获得的最大价值。

②定义状态转移方程

大家知道动态规划满足无后向性，即：每个阶段的决策仅受之前决策的影响，但是不影响之后各阶段的决策。所以我们可以从后往前推出状态转移方程，我们考虑两种情况：

当背包已经装不下其它物品时，则满足dp[i][j] = dp[i-1][j],其中j < w[i](剩余物品的重量)。
	当背包还能装下其它物品时，则满足dp[i][j] = dp[i-1][ j - w[i] ] + v[i]。
我们都知道装入背包方案有多种，要选择价值总和最大的方案，所以得出状态转移方程如下所示：

       dp[i][j] = max( dp[i-1][j] , dp[i-1][ j - w[i] ] + v[i] )

这个方程与Floyd算法的状态转移方程非常相似，如果有兴趣可以搜索一下。

③确定边界

由状态定义我们可以得出当j = 0时，dp[i][0] = 0;

三、代码编写

#include "stdio.h"

 

#define V 10

#define N 5

#define max(a,b) ((a)>(b)?(a):(b))

 

 

 

int main(){

 

    //物品的价值和重量列表

 	int value[] = {0, 8 , 10 , 4 , 5 , 5};

	int weight[] = {0, 6 , 4 , 2 , 4 , 3};

	//dp[j]表示容量为j的背包可以获得的最大价值。

	int dp[N+1][V+1] = {0};

    //核心算法

	int i,j;

	for(i = 1; i <= N; i++){

		for(j = 1; j <= V; j++){

			if(j >= weight[i]){

                dp[i][j] = max(dp[i-1][j],dp[i-1][j-weight[i]] + value[i]);

			}

			else{

                dp[i][j] = dp[i-1][j];

			}

		}

	}

 

	printf("最大价值为：%d",dp[N][V]);

	return 0;

}

版权声明：本文为CSDN博主「仁者乐山智者乐水」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_39559641/article/details/98732317



（     二     ）
动态规划系列――原理与思想
            
            
                
                    
                    原创                                                                                                                                            仁者乐山智者乐水
                    最后发布于2019-08-05 17:52:54                    
                    阅读数 164
                    
                        
                        收藏
                    
                
                                
                
                
                                                                展开
                                    
            
        
    
    
        
                
                
                                    
         
            
                                        
                
                                            一、适用范围

        每种方法都有自身的局限性，动态规划法也不是万能的。动态规划适合求解多阶段（状态转换）决策问题的最优解，也可用于含有线性或非线性递推关系的最优解问题，但是这些问题都必须满足最优化原理和子问题的“无后向性”。

最优化原理：最优化原理其实就是问题的最优子结构的性质，如果一个问题的最优子结构是不论过去状态和决策如何，对前面的决策所形成的状态而言，其后的决策必须构成最优策略。也就是说，不管之前决策是否是最优决策，都必须保证从现在开始的决策是在之前决策基础上的最优决策，则这样的最优子结构就符合最优化原理。
	无后向性（无后效性）：所谓“无后向性”，就是当各个阶段的子问题确定以后，对于某个特定阶段的子问题来说，它之前的各个阶段的子问题的决策只影响该阶段的决策，对该阶段之后的决策不产生影响，也就是说，每个阶段的决策仅受之前决策的影响，但是不影响之后各阶段的决策。
二、基本思想

       和分治法一样，动态规划解决复杂问题的思路也是对问题进行分解，通过求解小规模的子问题再反推出原问题的结果。但是动态规划分解子问题不是简单地按照“大事化小”的方式进行的，而是沿着决策的阶段划分子问题，决策的阶段可以随时间划分，也可以随着问题的演化状态划分。分治法要求子问题是互相独立的，以便分别求解并最终合并出原始问题的解，但是动态规划法的子问题不是互相独立的，子问题之间通常有包含关系，甚至两个子问题可以包含相同的子子问题。比如，子问题A的解可能由子问题C的解递推得到，同时，子问题B的解也可能由子问题C的解递推得到。对于这种情况，动态规划法对子问题C只求解一次，然后将其结果保存在一张表中（此表也称为备忘录），避免每次遇到这种情况都重复计算子问题C的解。除此之外，动态规划法的子问题还要满足“无后向性”要求。动态规划法不像贪婪法或分治法那样有固定的算法实现模式，作为解决多阶段决策最优化问题的一种思想，它没有具体的实现模式，可以用带备忘录的递归方法实现，也可以根据堆叠子问题之间的递推公式用递推的方法实现。但是从算法设计的角度分析，使用动态规划法一般需要四个步骤，分别是定义最优子问题、定义状态、定义决策和状态转换方程以及确定边界条件，这四个问题解决了，算法也就确定了。接下来就结合几个实例分别介绍这四个步骤，这几个例子分别是《算法导论》一书]中介绍的装配站问题、前文提到的背包问题以及经典的最长公共子序列问题（longest common subsequence）。

三、通用步骤

1.定义最优子问题 
        定义最优子问题，也就是确定问题的优化目标以及如何决策最优解，并对决策过程划分阶段。所谓阶段，可以理解为一个问题从开始到解决需要经过的环节，这些环节前后关联。划分阶段没有固定的方法，根据问题的结构，可以按照时间顺序划分阶段，也可以按照问题的演化状态划分阶段。阶段划分以后，对问题的求解就变成对各个阶段分别进行最优化决策，问题的解就变成按照阶段顺序依次选择的一个决策序列。
       装配站问题的阶段划分比较清晰，把工件从一个装配站移到下一个装配站就可以看作是一个阶段，其子问题就可以定义为从一个装配站转移到下一个装配站，直到最后一个装配站完成工件组装。对于背包问题，每选择装一个物品就可以看作一个阶段，其子问题就可以定义为每次向包中装一个物品，直到超过背包的最大容量为止。最长公共子序列问题可以按照问题的演化状态划分阶段，这需要首先定义状态，有了状态的定义，只要状态发生了变化，就可以认为是一个阶段。

2.定义状态
       状态既是决策的对象，也是决策的结果，对于每个阶段来说，对起始状态施加决策，使得状态发生改变，得到决策的结果状态。初始状态经过每一个阶段的决策（状态改变）之后，最终得到的状态就是问题的解。当然，不是所有的决策序列施加于初始状态后都可以得到最优解，只有一个决策序列能得到最优解。状态的定义是建立在子问题定义的基础上的，因此状态必须满足“无后向性”要求。必要时，可以增加状态的维度，引入更多的约束条件，使得状态定义满足“无后向性”要求。
        装配站问题的实质就是在不同的装配线之间选择装配站，使得工件装配完成的时间最短，其状态s[i]就可以定义为通过第i条装配线的第；个装配站所需要的最短时间。背包问题本身是个线性过程，但是如果简单将状态定义为装入的物品编号，也就是定义s[il为装入第i件物品后获得的最大价值，则子问题无法满足“无后向性”要求，原因是之前的任何一个决策都会影响到所有的后序决策（因为装入物品后背包容量发生了变化），因此需要增加一个维度的约束。考虑到每装入一个物品，背包的剩余容量就会减少，故而选择将背包容量也包含的状态定义中。最终背包问题的状态s[i,j]定义为将第i件物品装入容量为i的背包中所能获得的最大价值。对于最长公共子序列问题，如果定义strl[1...i]为第一个字符串前i个字符组成的子串，定义str2[1...j为第二个字符串的前i个字符组成的子串，则最长公共子序列问题的状态s[i,j]定义为strl[1...i]与str2[1...j]的最长公共子序列长度。

3.定义决策和状态转换方程
        定义决策和状态转换方程。决策就是能使状态发生转变的选择动作，如果选择动作有多个，则决策就是取其中能使得阶段结果最优的那一个。状态转换方程是描述状态转换关系的一系列等式，也就是从n-1阶段到n阶段演化的规律。状态转换取决于子问题的堆叠方式，如果状态定义得不合适，就会导致子问题之间没有重叠，也就不存在状态转换关系了。没有状态转换关系，动态规划也就没有意义了，实际算法就退化为像分治法那样的朴素递归搜索算法。
        对于装配站问题，其决策就是选择在当前工作线上的下一个工作站继续装配，或者花费一定的开销将其转移到另一条工作线上的下一个工作站继续装配。如果定义a[i,j]为第i条工作线的第；个装配站需要的装配时间，k[i,j]为从另一条工作线转移到第i条装配线的第/个装配站需要的转移开销，则装配站问题的状态转换方程可以描述为：



       背包问题的决策很简单，就是判断装入第i件物品获得的收益最大还是不装入第i件物品获得的收益最大。如果不装入第i件物品，则背包内物品的价值仍然是s[i-1,j]状态，如果装入第i件物品，则背包内物品的价值就变成 状态，其中 和   分别是第i件物品的容积和价值，决策的状态转换方程就是：



       最长公共子序列问题的决策方式就是判断strl[i]和str2[i]的关系，如果strl[i]与str2[i]相同，则公共子序列的长度应该是s[i-1,j-1]+1，否则就分别尝试匹配strl[1....i+1]与str2[1...j]的最长公共子串，以及strl[1...i]与str2[1...j+1]的最长公共子串，然后取二者中较大的那个值作为s[i,j]的值。最长公共子序列问题的状态转换方程就是：



4.确定边界条件
       对于递归加备忘录方式（记忆搜索）实现的动态规划方法，边界条件实际上就是递归终结条件，无需额外的计算。对于使用递推关系直接实现的动态规划方法，需要确定状态转换方程的递推式的初始条件或边界条件，否则无法开始递推计算。
        对于装配站问题，初始条件就是工件通过第一个装配站的时间，对于两条装配线来说，工件通过第一个装配站的时间虽然不相 同，但是都是确定的值，就是移入装配线的开销加上第一个装配站的装配时间。因此装配站问题的边界条件就是：
                                             s[1,1]=k[1,1]+a[1,1]
                                             s[2,1]=k[2,2]+a[2,2]
         背包问题的边界条件很简单，就是没有装入任何物品的状态：
                                            s[0，Vmax]=0
         确定最长公共子序列问题的边界条件，要从其决策方式入手，当两个字符串中的一个长度为0的时候，其公共子序列长度肯定是0，因此其边界条件就是：
                                            s[i,j]=0; i=0或j=0
――――――――――――――――
版权声明：本文为CSDN博主「仁者乐山智者乐水」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_39559641/article/details/98500565


栈的例题！！！！！！
建立栈！！
题目描述
小鱼最近被要求参加一个数字游戏，要求它把看到的一串数字（长度不一定，以0结束，最多不超过100个，数字不超过2^32-1），记住了然后反着念出来(表示结束的数字0就不要念出来了)。这对小鱼的那点记忆力来说实在是太难了，你也不想想小鱼的整个脑袋才多大，其中一部分还是好吃的肉！所以请你帮小鱼编程解决这个问题。
输入格式
一行内输入一串整数，以0结束，以空格间隔。
输出格式
一行内倒着输出这一串整数，以空格间隔。
#include <stdio.h>
int a[101];
int top = 0, c;
int main()
{
	while (1)
	{
		scanf("%d", &c);
		if (c == 0)
		{
			break;
		}
		a[++top] = c;
	}
	while (top != 0)
	{
		printf("%d ", a[top--]);
	}
	return 0;
}


分治法：
题目描述
任何一个正整数都可以用
22
2的幂次方表示。例如
137=27+23+20137=2^7+2^3+2^0 
137=2
7
+2
3
+2
0
同时约定方次用括号来表示，即
aba^b
a
b
可表示为
a(b)a(b)
a(b)。
由此可知，
137137
137可表示为：
2(7)+2(3)+2(0)
进一步：
7= 2^2+2+2^0$$ (2^1用2表示)，并且 $$3=2+2^0
所以最后
137可表示为：
2(2(2)+2+2(0))+2(2+2(0))+2(0)
又如：
1315=210+28+25+2+1
所以
13151315
1315最后可表示为：
2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)
输入格式
一个正整数
n(n≤20000)n(n≤20000)
n(n≤20000)。
输出格式
符合约定的
nn
n的
0,20,2
0,2表示(在表示中不能有空格)
输入输出样例
输入 #1 
复制 
1315
输出 #1 
复制 
2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)

P1010 幂次方 题解
这里给大家提供两种解法
―― 一种很朴实 一种很高级 ――
++其实是高级的那种解法很少人写++
----括号及加号的添加我放在后面写了----
模拟递归
这个算法很多人都会写了，思路如下：
算出2的多少次幂最接近给出的n；
用原来n的数减去2的幂，如果这个数大于2，继续对新的n进行搜索；
如果幂大于2，对幂进行上述搜索；
一旦输入函数的数为0（2的0次幂）或1（2的1次幂）或2（2的二次幂），输出；
至此，思路就很清晰了，那么我就上代码吧（很多人都会了不详解了）
//认真看，杜绝抄袭 
#include<cstdio>
using namespace std;
int n;
void search(int x)
{
    if(n!=0)
    {
        int p=1,q=0;
        printf("2");
        //每一次搜索都要输出2 
        //如果是1次幂就没必要写2(1)，后面会说; 
        while(x>=p)
        {
            ++q; 
            p*=2;   
        }
        //计算幂，由于这里会多算一次，所以计数器q-1; 
        --q;
        if(q==0 || q==2)printf("(%d)",q);
        //各种括号的判断
        if(q>=3)
        {
            printf("("); 
            search(q);
            printf(")");
        }
        x-=p/2;
        //上面计数器就是多算了一次，因此p也多乘了一个2; 
        if(x)//输入的数x为真（最后分解完就成0了，变成假），输出"+"; 
        {
            printf("+");search(x);
        }
    }
}
int main()
{
    scanf("%d",&n);
    search(n);
    return 0;//别忘了写;    
} 



下面讲一种高级的：
二进制数
我们知道，二进制数表示的其实就是一个正整数分解成为2的幂次方和！
如3用二进制表示为 11 ,从右到左分别是第0位，第1位……
则3=2^1+2^0(只要二进制那位是一，就是2^（这一位）)
再比如10 二进制是1010，则10=2^3+2^1;
大家自己体会一下
下面更高级的：位运算（其实也不高级，就是没人做）
不会位运算的就用上面那种吧，个人觉得位运算更快（普通14ms，位运算11ms）
位运算具体问度娘吧
思路如下：
遍历n的二进制（从地位到高位），用数组储存该位为1的位数；如1010（即10），先记录第1位是1，最后记录到第3位是1；
遍历完成后，对高位先进行处理（即原来为i++，现在变为i--）
该位(就是幂的次数)大于2,，递归再次处理
一旦处理到该位小于3，输出；

这里着重点一下括号的添加：
在每一次递归搜索前，肯定是搜到2的几次幂，输出"2(";
搜索结束后，也有括号")"，但这里也肯定有个"+";
最后一个不能输出加号，要进行判断，具体看下面程序；
是最后一个不要"+"，不是就写个"+";
输入函数的幂小于3时，只要该次幂不等于1，输出（该次幂）
由于2的一次幂不会有括号，因此2的加号也不见了，特判幂=1；
同第3、4，只要2不是最后一个，输出"2+"，是最后一个输出"2";

二进制代码实现如下：
//认真看，杜绝抄袭 
#include<cstdio>
using namespace std;
void ASCII(int m)
{
    int i=0,k=m,u=0,h[50];
    while(k)//位运算实现；
    {
        if(k&1)h[++u]=i;
        //h[++u]相当于++u，h[u]…… 
        k>>=1;
        i++;
    }
    //据上面写的，u从1开始，无论如何一定会有输出； 
    while(u)//u为真 
    {
        if(h[u]<3)//具体括号判断；
        {
            if(h[u]==1 && u-1!=0)  printf("2+");
            else if(h[u]==1)       printf("2");

            if((h[u]==0||h[u]==2)&&(u-1!=0))  printf("2(%d)+",h[u]);
            else if(h[u]==0||h[u]==2)         printf("2(%d)",h[u]); 
            --u;//搜索下一个；
        }
        else
        {
            printf("2(");
            ASCII(h[u--]);
            //相当于h[u],--u; 
            //这里千万不能写成 h[--u],否则你会3个WA两个MLE； 
            if(u!=0)printf(")+");
            //由于u进行了自减，此时的u已经是下一个数了； 
            else printf(")");
            //判断括号；
        }   
    }
}
int main()
{
    int n;
    scanf("%d",&n);
    ASCII(n);
    return 0;//别忘了写；
}

十进制转化为二进制，递归实现：
#include <stdio.h>
void to_binary(unsigned long n);
int main()
{
	unsigned long number;
	printf("Enter an integer (q to quit):\n");
	while (scanf("%lu", &number) == 1)
	{
		printf("Binary equivalent : ");
		to_binary(number);
		putchar('\n');
		printf("Enter an integer (q to quit):");
	}
	printf("Done.\n");
	return 0;
}
void to_binary(unsigned long n)
{
	int r;
	r = n % 2;
	if (n >= 2)
	{
		to_binary(n / 2);
	}
	putchar(r == 0 ? '0' : '1');
	return;
}

欧几里得算法求最大公约数

欧几里得算法求最大公约数
            
            
                
                    
                    原创                                                                                                                                            Rjex
                    最后发布于2019-12-28 11:34:28                    
                    阅读数 18
                    
                        
                        收藏
                    
                
                                
                
                
                                                                展开
                                    
            
        
    
    
        
                
                
                                    
         
            
                                        
                
                                            欧几里得算法

     欧几里得算法又称为辗转相除法

算法原理

    a 可以表示成a = k*b + r，则r = a mod b ， 假设d是a,b的一个公约数，则有
    d|a, d|b，而r = a C kb，观察，不难得出 r能被d整除，即d|r（d|r表示r能被d除尽）。
    因此d是(b,a mod b)的公约数 反过来，假设d 是(b,a mod b)的公约数，记r = a mod b，则
    d | b , d |r ，但是a = kb +r，由于d能整除式的右端，因此也必然能整除左端的a，因此d也是(a,b)的公约数
    由上知， (a,b)的最大公约数必然能整除(b,amod b)，反之也是如此，故它们的最大公约数也相等。（证毕）按照此算法思想，
    求a和b的最大公约数,可以转化为“求b和a%b的最大公约数”来解决，而“求b和a%b的最大公约数”又可以转化为求“求a%b和            b%(a%b)的最大公约数”，依次类推：
    在其中一个等于0的时候（经过有限步，必然在某一时刻有一个等于0）
    此时最大公约数就是另一个数。

算法代码

  递归法
――――――――――――――――
版权声明：本文为CSDN博主「Rjex」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_42746999/article/details/103742701


#include<stdio.h> 

int gcd(int a,int b)
{

	if (b==0) return a;

	return gcd(b,a%b);

}

main(){

	int a;

	a = gcd(12,2);

	printf("%d\n",a);

}


迭代法


#include<studio.h>

int gcd(int a.int b){

	int t;

	while(b!=0){

	t = b;

	b = a%b;

	a = t;	

	}

	return a;

}

main(){

	int a;

	a = gcd(12,2);

	printf("%d\n",a);

}


筛法求素数吧。

学习了一下埃氏筛法求素数（给新生看的）

基本思路是：素数的倍数不是素数

那行了道理大家都懂，该咋写呢？

实现方法是：

        用一个bool型的prime数组memset成0，即一开始假设所有的数都是素数（如果不会memset就用for循环遍历一遍全部初始化成0），然后现在我们有两个已知的非素数（合数）prime[0], prime[1]就将它们初始化成1

        2是第一个素数吧，没问题吧？那现在开始了，循环一遍，把2的倍数全部初始化成1，如果2的某个倍数已经超过了我们给的范围，            就结束循环

        接下来找离2最近的素数，3吧，没问题吧？再执行上个循环，3的倍数也变成1了，再从3后面找，4已经被改成1了，那就是5了……

        后面一直循环就完了

        然后主函数里调用一下，输出!prime[i]，的i。范围内所有的素数都出来了吧，贴上代码看起来方便。
――――――――――――――――
版权声明：本文为CSDN博主「Cr42yHC1」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/Cr42yHC1/article/details/83069092




#include<bits/stdc++.h>

using namespace std;

const int MAXN = 1e6 + 5;

 

bool prime[MAXN];

 

void eratosthense(){

	memset(prime, 0, sizeof(prime));

	int m = sqrt(MAXN);

	prime[0] = prime[1] = 1;

	for(int i = 2; i <= m; i++){

		if(prime[i]){

			continue;

		}

		for(int j = i; j * i < MAXN; j++){

			prime[i * j] = 1;

		}

	}

}

 

int main(){

	eratosthense();

	for(int i = 0; i < MAXN; i++){

		if(!prime[i]){

			cout << i << " ";

		}

	}

	return 0;

}

康托展开&逆康托展开
            
            
                
                    
                    原创                                                                                                                                            Vas_Sago
                    最后发布于2017-04-30 17:39:14                    
                    阅读数 221
                    
                        
                        收藏
                    
                
                                
                
                
                                                                展开
                                    
            
        
    
    
        
                
                
                                    
         
            
                                        
                    
                    
                                            康托展开是一个全排列到一个自然数的双射，常用于构建哈希表时的空间压缩。 康托展开的实质是计算当前排列在所有由小到大全排列中的顺序，因此是可逆的。

公式 
 
其中, 为整数,并且康托展开简单点说就是，判断这个数在其各个数字全排列中从小到大排第几位。 
比如 132，在1、2、3的全排列中排第2位。

康托展开求法： 
比如2143 这个数：
――――――――――――――――
版权声明：本文为CSDN博主「Vas_Sago」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_15015129/article/details/71023779

从头开始判断,
  
  ① 比 2（第一位数）小的数有多少个-> 1个就是1，1*3!
  
  ② 比 1（第二位数）小的数有多少个-> 0个0*2!
  
  ③ 比 4（第三位数）小的数有多少个-> 3个就是1,2,3，但是1,2之前已经出现，所以是 1*1!
  
  X=1*3!+0*2!+1*1!+0*0! = 7
  
  比该数小的数有7个，所以该数排第8的位置。
  
  1234 1243 1324 1342 1423 1432 2134 2143 2314 2341 2413 …(略)


既然是双射，那么也可以反推求出2143：


  ① 首先我们需要推出a序列 
  7 / 3! = 1 所以 a[3] = 1  , 7 % 3! = 1, 
  1 / 2! = 0 所以 a[2] = 0 , 1 % 2! = 1, 
  1 / 1! = 1 所以 a[1] = 1 , 1 % 1! =0, 
  同理a[0] = 0. 
  所以得到a数组为1 0 1 0
  
  ② 再由a数组推出序列，根据a数组的意义反推。 
  a[3] = 1, 表示它在1 2 3 4 序列中比它小的有1个，即它自己排第2，它等于2 
  a[2] = 0, 表示它在1 3 4序列中比它小的有0个，即他是最小的，它等于1 
  a[1] = 1, 表示它在3 4序列中比它小的有1个，即它自己排第2，它等于4 
  a[0] = 0, 表示它在3中最小，只能是3 
  因此序列为2 1 4 3


应用

一个直观的应用就是给定一个自然数集合和一个序列，求这个序列中按从小到大的顺序排第几个? 
比如对于1 2 3 4 5, 序列3 1 2 5 4比它小的序列有49个，即它排第50

另一个应用就是逆推第K个排列是多少，比如第50个全排列是多少？则首先减1得到49, 再反推即可得到3 1 2 5 4

另外在保存一个序列，我们可能需要开一个数组，如果能够把它映射成一个自然数， 则只需要保存一个整数，大大压缩空间.

计算 
编码
――――――――――――――――
版权声明：本文为CSDN博主「Vas_Sago」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_15015129/article/details/71023779


static const int Factorial[] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880};
int cantor(int *a, int n)
{
    assert(n < 10);
    int ans = 0;
    for (int i = 0; i < n; ++i) {
        int small = 0;
        for (int j = i + 1; j < n; ++j) {
            if (a[j] < a[i])
                small++;
        }
        ans += Factorial[n - i - 1] * small;
    }
    return ans;
}

解码

void decantor(int *a, int n, int k)
{
//由于使用set容器，所以序列不能有重复，否则要换容器
    set<int> num;
    for(int i=1;i<=n;i++)
        num.insert(i);
    int cur = 0;
    for (int i = n - 1; i > 0; --i) {
        int index = k / Factorial[i];
        k %= Factorial[i];
        set<int>::iterator it=next(num.begin(),index);
        a[cur++] = *it ;num.erase(*it);
    }
    set<int>::iterator it=num.begin();
    a[cur] = *it;
    num.clear();
}


test:

int main()
{
    int n,number[20],denumber[20];
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>number[i];
    }
    int ans=cantor(number,n);
    cout<<ans<<endl;
    decantor(denumber,n,ans);
    for(int i=0;i<n;i++){
        cout<<denumber[i]<<" ";
    }
    cout<<endl;
    return 0;
}


运用
对于aa      aa数组这个排列，其康拓展开式如下
X=A[0]?(n?1)!+A[1]?(n?2)!+…A[n]?0!X=A[0]?(n?1)!+A[1]?(n?2)!+…A[n]?0!      X = A[0]*(n-1)!+A[1]*(n-2)!+…A[n]*0!X=A[0]?(n?1)!+A[1]?(n?2)!+…A[n]?0!
A[i]A[i]      A[i]A[i]为ii      ii后比a[i]a[i]      a[i]a[i]小的数的数量
――――――――――――――――
版权声明：本文为CSDN博主「默_C202009」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/zyz_bz/article/details/89950311


逆康托展开
听名字就知道，就是倒过来，用编号还原排列
举个例子，
53241是5的全排列中编号为111的数
用111得到53241的过程如下：
用 111/4!=4余15，说明比首位小的数有4个，所以首位为55，余数继续辗转。
用15/3!=215/3!=2      15 / 3! = 215/3!=2余33      33，说明在第二位之后小于第二位的数有22      22个，所以第二位为33      33，余数继续辗转。
用 3/2!=13/2!=1      3 / 2! = 13/2!=1余11      11，说明在第三位之后小于第三位的数有11      11个，所以第三位为22      22，余数继续辗转。
用1/1!=11/1!=1      1 / 1! = 11/1!=1余00      00，说明在第四位之后小于第四位的数有11      11个，所以第四位为44      44（2,3,5都取过了），余数继续辗转。
用0/0!=00/0!=0      0 / 0! = 00/0!=0余0，说明在第五位之后小于第五位的数有00      00个，所以第五位为11      11，结束n次循环。
――――――――――――――――
版权声明：本文为CSDN博主「默_C202009」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/zyz_bz/article/details/89950311

同余定理
转载
ren_hui 最后发布于2013-04-14 18:32:29 阅读数 705 

收藏 
展开 
 
同余定理  
一、 同余
对于整数除以某个正整数的问题，如果只关心余数的情况，就产生同余的概念。
定义1 用给定的正整数m分别除整数a、b，如果所得的余数相等，则称a、b对模m同余，记作a≡b(mod m)，如 56≡0 （mod 8）。
定理1  整数a,b对模m同余的充要条件是 a-b能被m整除（即m|a-b）。
证  设a=mq1+r1, 0<=r1<m;
   b=mq2+r2, 0<=r2<m.
若a≡b(mod m)，按定义1，r1=r2,于是a-b=m(q1+q2),即有m|a-b.
反之，若m|a-b,即m|m(q1-a2)+r1-r2，则m|r1-r2，但|r1-r2|<m，故r1=r2,即a≡b(mod m)。
推论   a≡b(mod m)的充要条件是a=mt+b（t为整数）。
表示对模m同余关系的式子叫做模m的同余式，简称同余，同余式的记号是高斯（Gauss）在1801年首先使用的。
定理2  同余关系具有反身性、对称性与传递性，即
1）a≡a (mod m);
2）若a≡b (mod m), 则b≡a (mod m);
3）若a≡b (mod m), b≡c (mod m)，则a≡c (mod m).
定理3 若a≡b(mod m), c≡d (mod m),则
1）a+c≡b+d (mod m);
2）a-c≡b-d (mod m);
3）ac≡bd (mod m).
多于两个的同模同余式也能够进行加减乘运算。对于乘法还有下面的推论：
推论  若a≡b(mod m),n为自然数，则an≡bn (mod m)。
定理4 若ca≡cb(mod m), (c,m)=d, 且a,b为整数，则a≡b(mod m/d).
推论若ca=cb(mod m), (c,m)=1,且a,b为整数，则a≡b(mod m).
定理5 若a≡b (mod m),a≡b (mod n),则a≡b(mod [m,n]).
推论若a≡b(mod mi), i=1,2,…,n，则a≡b (mod [m1,m2,..,mn]).
 
例1 证明：正整数a是9的倍数必须且只须a的各位数码之和是9的倍数。
证  设a=an.10n+an-1.10n-1+…+a0
由10≡1 (mod 9)得10k≡1(mod 9),k=0,1,2,…,n，
所以 ak.10k≡ak (mod 9), k=0,1,2,…,n。
所以a≡a0+a1+...+an (mod 9)
因此 9|a的充要条件是 9| a0+a1+...+an  。
例2 设a=anan-1…a1a0,求11|a的充要条件。
解由10≡-1 (mod 11),得10k≡(-1)k (mod 11), k=0,1,2,…,n
   而 a≡a0-a1+a2-…+(-1)nan (mod 11)
  因此 11|a的充要条件是11| a0-a1+a2-…+(-1)nan.
例3 求正整数a能被7整除的条件。
解  由于 1000≡-1 (mod 7)，从而1000k≡(-1)k (mod 7), k=0,1,2,…,n,
 于是设a= anan-1…a1a0 (1000)  这就有a≡a0-a1+a2-…+(-1)nan (mod 7)
 因此 7|a的充要条件是a0-a1+a2-…+(-1)nan≡0 (mod 7) 这里的ai为三位数（一千进制）.
 如当a=89101234579时，由于579-234+101-89=357≡0 (mod 7)，所以7|a。
定义2 如果m为自然数，集合Kr={x|x=mt+r,t是任意整数}，r=0,1,…,m
则称K0,K1,…,Km-1为模m的剩余类。
例如，模2的剩余类是偶数类与奇数类；模3的剩余类是:K0={…,-6,-3,0,3,6,…}，K1={…,-5,-2,1,4,7,…}，K2={…,-4,-1,2,5,8…}。
剩余类具有如下列比较明显的性质：
1）模m的剩余类K0，K1，……，Km-1都是整数的非空子集；
2）每个整数必属于且只属于一个剩余类；
3）两个整数属于同一个剩余类的充要条件是它们对模m同余。
定义3 从模m的每个剩余类中任取一个数，所得到的m个数叫做模m的完全剩余系。
对模m来说，它的完全剩余系是很多的，经常采用的是：
0,1,2,…,m-1;
1,2,3,…,m;
-(m-1)/2,…,-1,0,1,…,m/2   (m为奇数)，
-m/2+1,…,-1,0,1,…,m/2     (m为偶数)，
-m/2,…,-1,0,1,…,m/2-1     (m为偶数).
 
定理6  k个整数a1,a2,…,ak构成模m的完全剩余系的充要条件是k=m，且这m个数对模m两两不同余。
定理7   若x1,x2,…,xm 是模m的完全剩余系，（a,m）=1,b为整数，则ax1+b，ax2+b，…，axm+b也是模m的完全剩余系。
二 欧拉函数
定义1 在模m的完全剩余系中，所有与m互素的数叫做模m的简化剩余系。例如1，3，7，9是模10的一个简化剩余系。
定义2 若对任意的自然数m，用记号ф(m)表示0,1,2,…,m-1中与m互素的数的个数，则称ф(m)为欧拉函数。
例如ф(10)=4，ф(7)=6，ф(1)=1。
定理1 k个整数a1,a2,…,ak构成模m简化剩余系的充要条件是k=ф(m)，(ai,m)=1,i=1,2,…, ф(m),且这ф(m)个数对模m两两不同余。
定理2 若(a,m)=1，x1,x2,…,xф(m)是模m的简化剩余系，则ax1,ax2,…,axф(m)也是模m的简化剩余系。
定理3(欧拉定理) 若(a,m)=1，则aф(m) ≡1 (mod m)
证 设x1,x2,…,xф(m)是模m的简化剩余系，根据定理2，ax1,ax2,…,axф(m)也是模m的简化剩余系。
由此可知x1,x2,…,xф(m)中任一个数必与ax1,ax2,…,axф(m)中某一个数对模m同余；反之ax1,ax2,…,axф(m)中任一个数必与x1,x2,…,xф(m)中某一个数对模m同余，这就有：
ax1ax2…axф(m)≡x1x2…xф(m) (mod m),又(x1x2…xф(m),m)=1,所以aф(m) ≡1 (mod m)。
例1 已知x=h是使ax≡1 (mod m)中成立的最小正整数，求证h|ф(m)。
证 由ah-1=mt(t为整数)可知(a,m)=1，于是
aф(m) ≡1 (mod m)。
令ф(m)=hq+r,0<=r<h, q为自然数
代入上面的同余式，可得 ar ≡1 (mod m),所以r=0，故h|ф(m)。
推论（费马小定理） 若p是素数，则
1） 当(a,p)=1时，ap-1 ≡1 (mod p)；
2） ap ≡a (mod p)
证 先证1）。由p是素数，知0,1,2,…,p-1中有p-1个数与p互素，于是ф(p)=p-1。又因为(a,p)=1，所以根据定理3得证1）。
再证2）。当(a,p)=1时，由1）知2)成立；当(a,p)不等于1时，p|a，余数同为0,2)也成立。
欧拉在1760年证明了定理3，故称为欧拉定理。费马在1640年提出了上面的推论，它的证明是欧拉在1736年完成的，这个推论通常叫做费马小定理。
例2 设a为整数，求证a5≡a(mod 30).
证 由于30=2.3.5，而依据费马小定理，有
a5≡a(mod 5) (1)
a3≡a(mod 3) (2)
a2≡a(mod 2) (3)
由(2)得 a5≡a3≡a(mod 3) （4）
由(3)得a5≡a4≡a2≡a(mod 2) (5)
于是由(1).(4),(5)，并且2,3,5两两互素，所以 a5≡a(mod 30).
定理4 若p是素数，则ф(pa)=pa-pa-1。 （ф(pa)的计算公式）
证 考虑模pa的完全剩余系0,1,2,…,p,…,2p,…,pa-1 (1)
(1)式中与pa不互素的数只有p的倍数0,p,2p,…,(pa-1C1)p,这共有p a-1个，于是(1)中与pa互素的数有pa-pa-1个，所以ф(pa)=pa-pa-1。
定理5 若(m,n)=1,则ф(mn)=ф(m)ф(n)。
推论 若正整数m1,m2,…mk两两互素，则ф(m1m2…mk)=ф(m1)ф(m2)…ф(mk).
定理6 若m的标准分解式为m=p1a1p2a2…pkak,
则ф(m)=p1a1-1p2a2-1…pkak-1(p1-1)(p2-1)…(pk-1).
例3 设(n,10)=1,求证n101与n的末三位数相同。
证：为了证明n101-n≡0只要证明n100≡1(mod 1000).
事实上由(n,125)=1,φ(125)= φ(5^3)=5^3-5^2=100，有n100≡1(mod 125);
再由n是奇数知8|n^2-1，进而n^100≡1(mod 8),而(125,8)=1，得证。


基础算法（五）次方求模
            
            
                
                    
                    原创                                                                                                                                            Bee_Darker
                    最后发布于2018-11-06 23:54:44                    
                    阅读数 205
                    
                        
                        收藏
                    
                
                                
                
                
                                                                展开
                                    
            
        
    
    
        
                
                
                                    
         
            
                                        
                
                                            1.问题描述

求a 的 b 次方对 c 取余的值。

输入：第一行输入一个整数 n ，表示测试数据的组数（n <100），每组数据只有一行，其中有三个正整数 a，b，c(1 ≤a，b，c≤10000000000)

输出：a的b次方对c取余之后的结果。

样例输入：


3

2                3                  5

3                100              10

11               12345          12345

 


样例输出：


3

1

10481 


2.解决方法

1）将幂拆解为多个底数的平方次的积；

2）如果指数为偶数，把指数除以2，并让底数的平方次取余 ；

3）如果指数为奇数，就把多出来的底数记录下来，再执行偶数次操作。

3.代码实现

#include<iostream>

using namespace std;

 

long long PowerMod(long long a,long long b,long long c)

{

	long long ans = 1;

	while(b)

	{

		if(b % 2)

			ans *= a %c;

		a = a*a%c;

		b /= 2;

	}

	ans %= c;

	return ans;

}

 

int main()

{

	int T;

	cin>>T;

	while(T--)

	{

		long long a,b,c,ans;

		cin>>a>>b>>c;

		ans = PowerMod(a,b,c);

		cout<<ans<<endl;

	}

	return 0;

}

――――――――――――――――
版权声明：本文为CSDN博主「Bee_Darker」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/Bee_Darker/article/details/83796207

基本算法（六）折半查找
            
            
                
                    
                    原创                                                                                                                                            Bee_Darker
                    最后发布于2018-11-17 20:46:38                    
                    阅读数 54
                    
                        
                        收藏
                    
                
                                
                
                
                                                                展开
                                    
            
        
    
    
        
                
                
                                    
         
            
                                        
                
                                            1.查找过程

首先，假设数列是递增的。查找时，先查找中间的数，若待差的数与中间的数相等，则查找成功；若待查的数比中间的数小，则到数组的前半部分查找；否则待查数比中间数大，则到数组的后半部分查找。以同样的方法在选定的区域中进行查找，每次都会将查找范围缩小一半，较快便能找到目的数。直到将查找区域缩小为0，如果找到了要查找的数，则查找成功，否则查找失败，表明有序数列中没有要查找的数。

2.算法要求

数列必须单调递增或单调递减。

3.示例

在有序数列（11,22,33,44,55,66,77,88,99）中查找66。

解答

用折半查找（二分查找）法要用到3个游标变量：front，tail和mid。其中front和tail分别指示被查找区域的头尾位置，以此公式mid =(front + tail)/2来确定每次查找区域的中间位置。

流程图



图解 



代码实现


#include<iostream>

using namespace std;

 

/*折半查找*/

int binsearch(int x,int arr[],int n)

{

	int front = 0,tail = n-1,mid;

	while(front <= tail)

	{

		mid = (front + tail)/2;

		if(x < arr[mid])

			tail = mid - 1;

		else

			if(x > arr[mid])

				front = mid + 1;

			else

				return mid;

	}

	return -1;

}

 

 

int main()

{

	int index,elem;

	int data[9] = {11,22,33,44,55,66,77,88,99};

	cin>>elem;

	index = binsearch(elem,data,9);

	if(index >= 0)

		cout<<"要查找的数在数组中位置:"<<index<<endl;

	else

		cout<<"查无此数"<<endl;

	return 0;

}

――――――――――――――――
版权声明：本文为CSDN博主「Bee_Darker」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/Bee_Darker/article/details/84191971

三点顺序（计算几何基本 --矢量叉积 详解）
            
            
                
                    
                    原创                                                                                                                                            短发--短发
                    最后发布于2018-04-02 17:59:51                    
                    阅读数 875
                    
                        
                        收藏
                    
                
                                
                
                
                                                                展开
                                    
            
        
    
    
        
                
                
                                    
         
            
                                        
                
                                            三点顺序描述现在给你不共线的三个点A,B,C的坐标，它们一定能组成一个三角形，
现在让你判断A，B，C是顺时针给出的还是逆时针给出的？如：图1：顺时针给出图2：逆时针给出          <图1>                   <图2>
输入每行是一组测试数据，有6个整数x1,y1,x2,y2,x3,y3分别表示A,B,C三个点的横纵坐标。
（坐标值都在0到10000之间）输入0 0 0 0 0 0表示输入结束测试数据不超过10000组输出如果这三个点是顺时针给出的，请输出1，逆时针给出则输出0
样例输入0 0 1 1 1 3
0 1 1 0 0 0
0 0 0 0 0 0样例输出0
1计算几何基础------有用到矢量叉积右手定理 ， 这点较难理解判断a * b 向量的方向：
1，四指指向a向量（右手垂直于平面） 2 ， 四指朝b向量弯曲（注意弯曲方向的夹角要小于180°）
3，大拇指指向为a*b的方向利用矢量叉积右手定理来判断是逆时针还是顺时针：
    设A(x1,y1),B(x2,y2),C(x3,y3),则三角形两边的矢量分别是：    AB=(x2-x1,y2-y1), AC=(x3-x1,y3-y1)    则AB和AC的叉积为：(2*2的行列式)    |x2-x1, y2-y1|    |x3-x1, y3-y1|    值为：(x2-x1)*(y3-y1) - (y2-y1)*(x3-x1)    
利用右手法则进行判断：    如果AB*AC>0,则三角形ABC是逆时针的    如果AB*AC<0,则三角形ABC是顺时针的    解释：
右手法则解释：a * b = (x2-x1)*(y3-y1) - (y2-y1)*(x3-x1)如果a * b 的值小于0  ， 则表示 a 和 b 之间的夹角大于180°再利用右手法则来判断 两条线段之间的夹角是顺时针还是逆时针的。 a * b 的值大于 0 时  ， 同理 
注释：利用右手定则判断第三个向量的方向，因为他原本为Z轴，如果为向上，则大于0，夹角小于180度，如果向下，则小于0.

#include <stdio.h>

#include <iostream>

using namespace std;

int main()

{

	int x1 , y1 , x2 , y2 , x3 , y3;

	while(cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3)

	{

		if(x1 == 0 && y1 == 0 && x2 == 0 && y2 == 0 && x3 == 0 && y3 == 0)

		{

			break;

		}

		int A = x2 - x1;

		int B = y2 - y1;

		int C = x3 - x1;

		int D = y3 - y1;

		if(A*D - B*C > 0)

		{

			cout << "0" << endl;

		}

		else

		{

			cout << "1" << endl;

		}

	}

	return 0;

 } 

――――――――――――――――
版权声明：本文为CSDN博主「短发--短发」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_41593380/article/details/79792643


题目描述
对于给定的一个长度为
NN
N的正整数数列
AiA_i
A
i
?

，现要将其分成连续的若干段，并且每段和不超过
MM
M（可以等于
MM
M），问最少能将其分成多少段使得满足要求。
输入格式
第1行包含两个正整数
N,MN,M
N,M，表示了数列
AiA_i
A
i
?

的长度与每段和的最大值，第
22
2行包含
NN
N个空格隔开的非负整数
AiA_i
A
i
?

，如题目所述。
输出格式
一个正整数，输出最少划分的段数。
输入输出样例
输入 #1 
复制 
5 6
4 2 4 5 1
输出 #1 
复制 
3
说明/提示
对于
20%20\%
20%的数据，有
N≤10N≤10
N≤10；
对于
40%40\%
40%的数据，有
N≤1000N≤1000
N≤1000；
对于
100%100\%
100%的数据，有
N≤100000,M≤109N≤100000,M≤10^9
N≤100000,M≤10
9
，
MM
M大于所有数的最小值，
AiA_i
A
i
?

之和不超过
10910^9
10
9
。
将数列如下划分：
[4][24][51][4][2 4][5 1]
[4][24][51]
第一段和为
44
4，第
22
2段和为
66
6，第
33
3段和为
66
6均满足和不超过
M=6M=6
M=6，并可以证明
33
3是最少划分的段数。
#include <cstdio>//头文件准备
using namespace std;
int n,m,ans=1;//ans的初值要为1
int main(){
    scanf ("%d %d",&n,&m);
    int k=0;
    while (n--){//完全的边读边做
        int a;
        scanf ("%d",&a);//读入a
        if (k+a<=m){//判断k+a是否大于m，如果大于，ans要加1，然后a独立为一段；如果小于等于，k就要加上a
            k+=a;
        }
        else{
            ans++;
            k=a;
        }
    }
    printf ("%d\n",ans);//做完之后输出，结束
    while (1);//反抄袭
}
#珍爱生命，拒绝抄袭！


很简单的一道题
首先读入，不解释；
其次从第一个开始搜索，定义一个sum表示这一段的和，每次搜索先判断sum与a[i]的和是否大于m(我发现全都用int类型就能过），
如果大于，ans++，sum归零，加上a[i]，重复以上。
如果小于等于，sum加上a[i]，重复以上；
最后有一个小坑，如果搜索完后，sum不为零，ans要+1；
输出,AC
END;
#include<cstdio>
using namespace std;
int a[100010] ;
int main()
{
    int n,m,i,j,k,ans=0,sum=0;
    scanf("%d%d",&n,&m);
    for(i=0;i<n;i++)
    {
        scanf("%d",&a[i]);
    }
    for(i=0;i<n;i++)
    {
        if(a[i]+sum>m)
        {
            sum=0;
            ans++;
        }
        sum=sum+a[i];
    }
    if(sum)
    {
        ans++;
    }
    printf("%d",ans);
    return 0;
}

本题并不难，你只要弄一个容器，往里面装，如果>m了就先把计数器加一，再把容器置为当前这个数，主要是数据太水了，
#include <bits/stdc++.h>
using namespace std;
int n,m,a[100005];
int count(){
    int s=1,t=0;//s就是能装多少个容器，t是模拟容器装的过程
    for (int i=1;i<=n;i++){
        t+=a[i];//往里面装
        if (t>m){
            s++;
            t=a[i];
}//如果装过头了，就再加一个容器，注意新容器里应该是a[i]
    }
    return s;
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++) cin>>a[i];//读入
    cout<<count();//简单明了
}

作为一个突然想浪费人生中的美好10分钟复习一下贪心的人
我点开了贪心标签，于是乎就水了这道题……
不多说了，其实这道题就是一个理解贪心正确性然后AC的题，不过这里有几点小建议要给大家：
1. 有时候在读入一个数据后立即进行处理能够让你的main函数变长程序更省空间，比如这道题，就不必开存储物品的大数组了，当然，这种水题也不必省空间吧……记住这点，只要是可以边读边操作的，都这样做！所以我的码风经常是这样的?
for(int i=1;i<=something1;i++)
{
    something2=read();
    solve();
}
2.贪心题的正确性判断，比如本题，一个新读入的数你要么放进原有的容器，要么放不进去就算了再来一个，正确性是显然的。当然，贪心的正确性在较大型的题目中是需要加以反复考虑的!
if(bucket+num[i]>lim)
//桶放不下了(在桶排序之后忘不了bucket了QwQ)
{
    cnt++;
    //多加一个桶，为什么只开一个桶？?
    bucket=0;
}
bucket+=num[i];
3.有时候你的处理就得比较巧妙了:
Q:为什么只开一个桶？
A:本题并不要求记录咋装的，不问过程就可以过河拆桥反复利用一个桶
又是那个思路，反复用一个不计路径的int数，用完再覆盖着用，都是为了省下空间
好吧，我也不期望你们能够有耐心看我在上面扯，放代码：
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int maxn=100010;
int n,lim;
int num[maxn];
ll bucket=0,cnt=1;
int main()
{
　　cin>>n>>lim;
　　//并不需要快读:个数，容量上限
　　for(int i=1; i<=n; i++)
　　{
　　　　cin>>num[i];
 　　  //并不需要快读:大小
　　　　if(bucket+num[i]>lim)
　　　　{
        　　bucket=0;
        　　cnt++;
          　//放不下加个桶重装
　　　　}
　　　　bucket+=num[i];
    　　//比较巧妙的放在外面，两个情况一次满足
　　}
　　cout<<cnt;
  　//一次完美的AC
}
听我一句劝:别抄我的题解，有毒！(亲测CE)
撒花??c(°°)ノ?
二位前缀和，牛逼！！用来缩减时间复杂度，用于数组求和，尤其是矩阵
https://blog.csdn.net/qq_34990731/article/details/82807870
这是本人的第一篇题解，哪里写的不好请见谅
这道题的正常思路思路很简单：
1）暴力（出奇迹）
2）先预处理再找点
我看到这道题的时候，发现这道题写暴力的话没有什么考点
so,我选择了写一个二维前缀和（二维前缀和是个很有用的东西，也是以后学OI中很常见的部件之一）
做题的步骤代码如下
（二维前缀和在本题中简化了下）
#include<iostream>
#include<cstdio>

using namespace std;

const int maxn=1e3+5;

int n;
long long ans;
int a[maxn][maxn],s[maxn][maxn];        // s表示前缀和数组
bool flag=false;                        //flag用来表示有没有位置可以放

void init()
{
    scanf("%d",&n);
    for(register int i=1;i<=n;i++) for(register int j=1;j<=n;j++) scanf("%d",&a[i][j]);
    for(register int i=1;i<=n;i++) for(register int j=1;j<=n;j++) s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j];//二维前缀和的预处理，不多解释
}

long long cal(int i,int j)
{
    return s[i][n]-s[i-1][n]+s[n][j]-s[n][j-1];//这个函数为个人习惯，也可以直接放到主函数里，但我认为那样看起来会比较难看
}

int main()
{
     init();//用来预处理的函数
     for(register int i=1;i<=n;i++)
       for(register int j=1;j<=n;j++)
       {
           if(!a[i][j]) flag=true,ans=max(ans,cal(i,j));//找点，并求出最佳的方案   flag用来表示有没有位置可以放
       }
     if(!flag) cout<<"Bad Game!"<<endl; //特判有没有能放的点
     else cout<<ans<<endl;
    return 0;
}
这道题就结束了。。
P.S:二维前缀和是未来学习的基础之一
题目背景
元宵节不放假挺郁闷的，于是时间机智的改到了星期6一整天！
题目描述
MedalPluS 和他的小伙伴 NOIRP 发掘了一个骨灰级别的游戏――超级弹珠。
游戏的内容是：在一个 n*n 的矩阵里，有若干个敌人，你的弹珠可以摧毁敌人，但只
能攻击你所在的行、列里的所有敌人，然后你就可以获得他们的分数之和，现在请你选择
一个你的位置，使得能击杀的敌人最多，注意，你不能和敌人在一个地方
输入格式
输入有两行，第一行一个正整数 n，接下来 n 行，每行 n 列，如果有敌人则为一个正整数，否则为 0
输出格式
输出共一行，最多分数，如果连你的容身之地都没有，请输出“Bad Game!”

C语言-dfs
            
            
                
                    
                    原创                                                                                                                                            Woo--k
                    最后发布于2019-12-29 22:00:09                    
                    阅读数 42
                    
                        
                        收藏
                    
                
                                
                
                
                                                                展开
                                    
            
        
    
    
        
                
                
                                    
         
            
                                        
                    
                    
                                            dfs原理
深度优先搜索的原理就是：一路走到底，如果发现此路不通就跳到上一级，找另一条路走到底。
如果发现此路通，则结束。
所以dfs的基本结构是：
――――――――――――――――
版权声明：本文为CSDN博主「Woo--k」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/TGYYS/article/details/103758148

void dfs(int step)
{
	......
	for(i=0;i<n;++i){
		......
		dfs(step+1);
		......
	}
	return;
}

这种结构的主体就是用for循环把每一种可能都包括进去，这一种可能结束后调用自己进行下一步的判断。
在逻辑上表现就是把当前这一步的所有可能都想到，并为下一步开个头，但重点还是”当前应该怎么做“，
至于下一步怎么做则与当前所要做的操作一样。
上例题：
B先生在一个迷宫里迷路了，他需要A先生的救助，A先生也不知道怎么走，所以他只能一步一步试。
现在编程来帮A先生解救B先生。
输入
m，n代表迷宫的长与宽。
m行，n列0或1.其中0代表路，1代表障碍。
出发坐标（x，y）与目标坐标（sx，sy）
输出
最短步数。
输入样例
――――――――――――――――
版权声明：本文为CSDN博主「Woo--k」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/TGYYS/article/details/103758148

5 4
0 0 1 0
0 0 0 0
0 0 1 0
0 1 0 0
0 0 0 1
1 1 4 3
输出样例
7
dfs代码块


我们首先用二维数组next构成4总走法，即向上下左右走。


接下来判断当前所在位置是否为目的地（避免A先生一开始就在B那里这样的情况）。


用一个min来存储最短步数。


接下来就是关键：用for循环找所有情况，每一种情况都有相应的运算以及下一步。

把越界，走过的路等情况全部考虑进。
最后return返回主函数。
void dfs(int x,int y,int step)
{
	int next[4][2]={{0,1},{1,0},{0,-1},{-1,0}};
	int i,nx,ny;
	if(x==p&&y==q){
		if(step<min)
			min=step;
		return;
	}	
	for(i=0;i<=3;++i){
		nx=x+next[i][0];
		ny=y+next[i][1];
		if(nx<1||ny<1||nx>n||ny>m)
			continue;
		if(a[nx][ny]==0&&book[nx][ny]==0){
			book[nx][ny]=1;
			dfs(nx,ny,step+1);
			book[nx][ny]=0;
		}	
	}
	return;
}

完整代码
#include<stdio.h>
int m,n,p,q,min=99999;
int a[51][51],book[51][51];
void dfs(int x,int y,int step)
{
	int next[4][2]={{0,1},{1,0},{0,-1},{-1,0}};
	int i,nx,ny;
	if(x==p&&y==q){
		if(step<min)
			min=step;
		return;
	}	
	for(i=0;i<=3;++i){
		nx=x+next[i][0];
		ny=y+next[i][1];
		if(nx<1||ny<1||nx>n||ny>m)
			continue;
		if(a[nx][ny]==0&&book[nx][ny]==0){
			book[nx][ny]=1;
			dfs(nx,ny,step+1);
			book[nx][ny]=0;
		}	
	}
	return;
}

int main()
{
	int i,j,sx,sy;
	scanf("%d%d",&n,&m);
	for(i=1;i<=n;++i)
		for(j=1;j<=m;++j)
			scanf("%d",&a[i][j]);
	scanf("%d%d%d%d",&sx,&sy,&p,&q);
	book[sx][sy]=1;
	dfs(sx,sy,0);
	printf("%d",min);
	return 0;
}
所以说广度优先搜索总是能找到一个问题的最优解，但它没有深搜那么莽夫，所以广搜所要花费的时间往往比深搜要久。
bfs的建立
bfs要先建立一个队列
struct node
{
	int ;//至少两个，一个表示数据，一个表示数据所在的位置。
};
用这个结构体来表示每一步与每一步所在的位置。
区别
dfs考虑的是当先该怎么做并用递归写出下一次，而bfs考虑的是下一次有几种做法。
我这里给出dfs的文章做对比dfs原理
例题
为了直观的显现出bfs与dfs的区别，我们用bfs来解我之前在dfs上的原题：
B先生在一个迷宫里迷路了，他需要A先生的救助，A先生也不知道怎么走，所以他只能一步一步试。
现在编程来帮A先生解救B先生。
输入
m，n代表迷宫的长与宽。
m行，n列0或1.其中0代表路，1代表障碍。
出发坐标（x，y）与目标坐标（sx，sy）
输出
最短步数。
输入样例
――――――――――――――――
版权声明：本文为CSDN博主「Woo--k」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/TGYYS/article/details/104147777


我们先建立一个结构体
#include<stdio.h>
struct node
{
	int x,y,s;//x，y为坐标，s为步数。
};
接下来是地图初始化与输入
truct node que[2501];//地图
 	int a[51][51]={0},book[51][51]={0};
 	int next[4][2]={{0,1},{1,0},{0,-1},{-1,0}};//方向
 	int head,tail;
 	int i,j,k,m,n,sx,sy,p,q,tx,ty,flag;
 	scanf("%d%d",&n,&m);//初始化地图
 	for(i=1;i<=n;++i)
 		for(j=1;j<=m;++j)
 			scanf("%d",&a[i][j]);
 	scanf("%d%d%d%d",&sx,&sy,&p,&q);//队列初始化
 	head=1;    //其他值的初始化
 	tail=1;
 	que[tail].x=sx;
 	que[tail].y=sy;
 	que[tail].s=0;
 	tail++;
 	book[sx][sy]=1;
 	flag=0;

接下来是bfs的关键
如果用dfs，我们就用一个dfs函数来模拟每一步。
void dfs(int x,int y,int step)
{
	int next[4][2]={{0,1},{1,0},{0,-1},{-1,0}};
	int i,nx,ny;
	if(x==p&&y==q){
		if(step<min)
			min=step;
		return;
	}	
	for(i=0;i<=3;++i){
		nx=x+next[i][0];
		ny=y+next[i][1];
		if(nx<1||ny<1||nx>n||ny>m)
			continue;
		if(a[nx][ny]==0&&book[nx][ny]==0){
			book[nx][ny]=1;
			dfs(nx,ny,step+1);
			book[nx][ny]=0;
		}	
	}
	return;
}

如果用bfs则：
1. 首先判断这个地方走没走过 *head<tail*
2. 列举四分方向
for(k=0;k<=3;++k){
 			tx=que[head].x+next[k][0];
 			ty=que[head].y+next[k][1];
 			if(tx<1||tx>n||ty<1||ty>m)
 				continue;
 			if(a[tx][ty]==0&&book[tx][ty]==0){//这里判断这一步是否走过
 				book[tx][ty]=1;
 				que[tail].x=tx;
 				que[tail].y=ty;
 				que[tail].s=que[head].s+1;
 				tail++;
			}

3.如果找到目的地了flag=1;并break;

if(tx==p&&ty==q){
	flag=1;
	break;
}
4.如果flag=1;则代表这里条路已经走完了，则进行下一次尝试head++
bfs部分完整代码：

while(head<tail){
 		for(k=0;k<=3;++k){
 			tx=que[head].x+next[k][0];
 			ty=que[head].y+next[k][1];
 			if(tx<1||tx>n||ty<1||ty>m)
 				continue;
 			if(a[tx][ty]==0&&book[tx][ty]==0){//和dfs一样乱七八糟的判断
 				book[tx][ty]=1;
 				que[tail].x=tx;
 				que[tail].y=ty;
 				que[tail].s=que[head].s+1;
 				tail++;
			}
			 if(tx==p&&ty==q){
			 	flag=1;
			 	break;
			}
		}
		if(flag==1)
			break;
		head++;
	}
在进行完这些步骤之后。最少的步数就模拟出来了。
接下来只需要进行一个简单的printf即可。
完整代码

#include<stdio.h>
struct node
{
	int x,y,s;//x，y为坐标，s为步数。
};
 
 int main()
{
	struct node que[2501];//地图
 	int a[51][51]={0},book[51][51]={0};
 	int next[4][2]={{0,1},{1,0},{0,-1},{-1,0}};//方向
 	int head,tail;
 	int i,j,k,m,n,sx,sy,p,q,tx,ty,flag;
 	scanf("%d%d",&n,&m);//初始化地图
 	for(i=1;i<=n;++i)
 		for(j=1;j<=m;++j)
 			scanf("%d",&a[i][j]);
 	scanf("%d%d%d%d",&sx,&sy,&p,&q);//队列初始化
 	head=1;
 	tail=1;
 	que[tail].x=sx;
 	que[tail].y=sy;
 	que[tail].s=0;
 	tail++;
 	book[sx][sy]=1;
 	flag=0;
 	while(head<tail){
 		for(k=0;k<=3;++k){
 			tx=que[head].x+next[k][0];
 			ty=que[head].y+next[k][1];
 			if(tx<1||tx>n||ty<1||ty>m)
 				continue;
 			if(a[tx][ty]==0&&book[tx][ty]==0){//和dfs一样乱七八糟的判断
 				book[tx][ty]=1;
 				que[tail].x=tx;
 				que[tail].y=ty;
 				que[tail].s=que[head].s+1;
 				tail++;
			}
			 if(tx==p&&ty==q){
			 	flag=1;
			 	break;
			}
		}
		if(flag==1)
			break;
		head++;
	}
	printf("%d",que[tail-1].s);
	return 0;
}




